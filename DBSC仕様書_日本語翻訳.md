# デバイスバウンドセッションクレデンシャル (DBSC)

> **注意**: この文書は [W3C DBSC 仕様](https://www.w3.org/TR/dbsc/) を Claude AI により日本語に翻訳したものです。翻訳の正確性は保証されません。正確な内容については必ず原文を参照してください。

**W3C 初回公開ワーキングドラフト**, 2025年8月21日

---

## 概要

デバイスバウンドセッションクレデンシャル（DBSC）は、安全に保管された秘密鍵の所有をユーザーエージェントが証明できるプロトコルとインフラストラクチャを構築することで、Cookie窃取によるハイジャックを防止することを目的としています。DBSCは、このバインディングを実現するためのWeb APIおよびユーザーエージェントとサーバー間のプロトコルです。

---

## 文書のステータス

この文書は、[Web Application Security Working Group](https://www.w3.org/groups/wg/webappsec)により、[勧告トラック](https://www.w3.org/policies/process/20250818/#recs-and-notes)を使用した初回公開ワーキングドラフトとして公開されました。この文書はW3C勧告となることを意図しています。

初回公開ワーキングドラフトとしての公開は、W3Cおよびそのメンバーによる承認を意味するものではありません。これはドラフト文書であり、いつでも更新、置換、または他の文書により廃止される可能性があります。進行中の作業以外のものとしてこの文書を引用することは不適切です。

---

## 目次

1. [はじめに](#1-はじめに)
2. [セキュリティに関する考慮事項](#2-セキュリティに関する考慮事項)
3. [プライバシーに関する考慮事項](#3-プライバシーに関する考慮事項)
4. [検討された代替案](#4-検討された代替案)
5. [サーバー側の考慮事項](#5-サーバー側の考慮事項)
6. [ユーザーエージェント側の考慮事項](#6-ユーザーエージェント側の考慮事項)
7. [フレームワーク](#7-フレームワーク)
8. [アルゴリズム](#8-アルゴリズム)
9. [DBSCフォーマット](#9-dbscフォーマット)
10. [他の仕様への変更](#10-他の仕様への変更)
11. [IANAに関する考慮事項](#11-ianaに関する考慮事項)
12. [変更履歴](#12-変更履歴)
13. [謝辞](#13-謝辞)

---

## 1. はじめに

*このセクションは規範的ではありません。*
*注意：これは執筆協力のみを目的とした非常に初期の草稿です。*

Webはステートレスプロトコルの上に構築されています。特定の機能のために状態を維持するため、Webアプリケーションはユーザーのデバイスにローカルにデータを保存します。この保存は長期間にわたる場合があり、ログインユーザーセッションのクレデンシャルなどのセキュリティ上機密性の高いデータに使用されます。

一般的に、ユーザーエージェントは、一般的なオペレーティングシステム上で、ユーザーエージェント自体と同等の権限を持つソフトウェアに対して安全な方法でこの種のデータを保存する手段を持っていません。同時に、このデータによって認証されるアクションは、銀行口座からの送金など、深刻な結果をもたらす可能性があります。このモデルに対する一般的でスケーラブルな脅威は、そのようなクレデンシャルを外部に送出し、別の場所で不正行為を実行するマルウェアであり、これにより検出を回避します。

この文書は、新しいAPI「デバイスバウンドセッションクレデンシャル（DBSC）」を定義し、セッションクレデンシャルがデバイスからエクスポートされていないことをサーバーが検証できるようにします。これらのクレデンシャルは秘密鍵であるため、ユーザーエージェントはTPMや類似のAPIなどの機能を使用して、同等の権限を持つマルウェアからもエクスポートを防ぐことができます。

目標は、ユーザーが既に慣れ親しんでいるユースケースを提供しながら、安全でセキュアな体験をユーザーに提供することです。同時に、このプロトコルによって新たなプライバシー識別子が漏洩しないよう、ユーザーのプライバシーが尊重されることを確保したいと考えています。このAPIは、既存のサーバーサイド認証スタックとの容易な統合に特別な注意を払い、Webソフトウェアスタックの大部分の書き換えを必要としない、段階的な保護への道を提供します。

---

## 2. セキュリティに関する考慮事項

DBSCの目標は、長寿命のCookieベアラートークンの代替を提供することでセッション窃取を軽減し、エクスポートからより適切に保護できる秘密鍵に基づいてセッション認証を行えるようにすることです。これにより、マルウェアがローカルでの動作を強制され、検出と軽減が容易になるため、ユーザーのIDが悪用される可能性が低くなり、インターネットがユーザーにとってより安全になります。

ユーザーエージェントの実装は、さまざまなプラットフォームに存在するマルウェアの脅威の種類と存在する保護メカニズムを考慮し、そのような秘密鍵をエクスポートから保護する最善の方法を選択する責任があります。これには、TPMやセキュアエレメントなどのセキュアハードウェア、安全な鍵生成と管理のためのOS提供のAPI、またはローカルで実行されるマルウェアに対する合理的な保護を提供するプロセス分離メカニズムが含まれますが、これらに限定されません。

セッションが有効であり、侵害されていないデバイスに登録されている限り、ホストはセッション鍵が異なるデバイスへの悪意あるエクスポートから保護されていることを暗号学的な確実性をもって知ることができます。

### 2.1. 非目標

DBSCは、攻撃者がユーザーのデバイスに常駐している間のブラウザセッションへの一時的なアクセスを防止しません。秘密鍵は最新のオペレーティングシステムが許す限り安全に保存されるべきであり、セッション秘密鍵のエクスポートを防止しますが、署名機能は、ユーザーのデバイス上でそのユーザーとして実行されるあらゆるプログラムが引き続き利用可能である可能性が高いです。

また、攻撃者がセッション登録時にユーザーエージェントを置換または注入している場合、DBSCは攻撃を防止しません。攻撃者は、TPMにバインドされていない鍵、または攻撃者が永続的に制御するTPMのいずれかにセッションをバインドできるためです。

DBSCは、セッションが登録されている特定のデバイスやそのデバイスの状態について、ホストにいかなる保証を与えるようにも設計されていません。

---

## 3. プライバシーに関する考慮事項

DBSCプロトコルのプライバシー目標は、ユーザー追跡のための追加の表面を導入しないことです：このAPIを実装すること（ブラウザの場合）または有効にすること（Webサイトの場合）は、重大なユーザープライバシーのトレードオフを伴うべきではありません。

これを確保するために取られた考慮事項の一部：

- **セッション/鍵素材のライフタイム：** これは追加のクライアントデータストレージ（つまり、疑似Cookie）を提供すべきではありません。そのため、ブラウザは他のサイトデータ（Cookieなど）をクリアする際に、セッションと鍵をクリアしなければなりません（MUST）。
- このAPIの実装は、ヒューリスティックなデバイスフィンガープリンティング信号のエントロピーを有意に増加させるべきではありません。特に、DBSCは安定したデバイス識別子を漏洩すべきではありません。
- このAPIはパフォーマンスのためにバックグラウンド「ping」を許可する可能性がある（MAY）ため、ユーザーが接続サイトから離れた場合にユーザーの長期追跡を可能にしてはなりません。
- 各セッションには新しい鍵が個別に作成され、異なるセッションが同じデバイスからのものであることを検出できるべきではありません。

### 3.1. Cookieに関する考慮事項

サイトがこのAPIを使用して同一オリジンポリシー、サードパーティCookieポリシーなどを回避することは不可能であるべきです。現在の変化するCookieの動作の複雑さとDBSCとCookieの密接な統合により、現在の解決策は、各ユーザーエージェントがCookieに使用するのと同じポリシーをDBSCに使用することです。ユーザー設定、適用されたポリシー、またはユーザーエージェントの実装の詳細に基づいてDBSC Cookieクレデンシャルがネットワークリクエストに適用されない場合、追加のDBSCの動作も適用されません。これにより、DBSCの実装による新たなプライバシーの動作が発生しないことを確保します。

### 3.2. タイミングサイドチャネル漏洩

サードパーティCookieが有効な場合、攻撃者はリクエストにかかる時間を測定することで、ユーザーが認証されているかどうかを判断できる可能性があります。これは、リフレッシュが非常に遅くなる可能性があるためで、特に鍵保護のための遅い基盤機能（例：TPM）に依存する場合です。

これは、セッション設定の `allowed_refresh_initiators` キーによって軽減されます。これを使用して、DBSCリフレッシュをトリガーできるサイトを厳密に制限できます。既存のソリューション（例：X-Frame-Options）はリクエストの完了後にのみ適用されるため、これを置き換えることはできません。DBSCはリクエストの開始前にリフレッシュするかどうかを選択する必要があります。

### 3.3. フェデレーテッドセッション

多くのサイトは、ブラウザの関与なしにフェデレーテッドログインメカニズムを使用しており、リンクデコレーション（例：OIDC）に頻繁に依存しています。DBSCの容易な採用可能性という目標を達成するために、これらのサイトが認証フローの完全な書き換えなしにCookie窃取から自身を保護できるようにしたいと考えています。理想的には、リライイングパーティ（RP）はIDプロバイダー（IdP）から独立してDBSCセッションを確立できるべきです。残念ながら、ほとんどのIdPは、ユーザーが既にログインしている場合にはパスワードを要求しません。ユーザーインタラクションが不要な場合、マルウェアはユーザーのマシンへの一時的なアクセスを使用してログインフローを模倣し、マルウェアが作成してエクスポートできる新しい秘密鍵でDBSCセッションを確立できます。これはDBSCのセキュリティ目標に違反します。

DBSCは本質的にログインやIDに紐付けられていないため、IDプロバイダーは最も正確な用語ではありません。代わりに「セッションプロバイダー（SP）」という用語を使用しますが、対象のユースケースではSPとIdPが同じ当事者であることを想定しています。

RPのセッションを保護するためには、RPとSPのセッションを何らかの方法でリンクする必要があります。最も簡単な方法は、SPとRPが同じセッション鍵ペアを使用することです。マルウェアがデバイスを侵害する前にSPのセッションが確立されたと仮定するため、秘密鍵が安全に保管されていると信頼します。しかし、サイト間で鍵を共有することには複雑なプライバシー特性があります。高エントロピーの識別子を共有するプライバシーリスクを軽減するために、RPが既にSPのセッションの公開鍵とセッション識別子を知っていることを要求します。RPは、`Secure-Session-Registration`ヘッダーにSPのURL、セッション識別子、およびbase64エンコードされたJWKサムプリント（[RFC4648]および[RFC7638]参照）を含めます。鍵が正しい場合、ユーザーエージェントはSPと同じ鍵でRP上にセッションを作成します。

悪意のあるRPとSPが協力して、RPとSPが既に情報を共有できない場合（例：フィンガープリンティングやリンクデコレーションに対する保護がある場合）にユーザーを識別しようとするリスクもあります。RPは、一致が見つかるまで多くの公開鍵を推測するだけで、ユーザーの一意の識別子を取得できます。これにより、協力するRPとSPは、クロスサイトID連携の意図されたメカニズムの外側でサイト間でユーザーのIDを共有できるようになります。これを防ぐために、ユーザーエージェントは登録試行に対して重要なバックオフまたはクォータを含めるべきです（これはTPMへのサービス拒否を回避するためにも推奨されます）。DBSCのセキュリティ特性は、2人のユーザーが同じ鍵ペアを持つことが困難であるという暗号学的な仮定に依存しているため、ユーザーがSP上に特定のDBSC公開鍵を持っているかどうかを照会することは1ビットのエントロピーよりもはるかに小さいことに注意してください。

ユーザーのアンマスキングに成功した場合の価値をさらに制限するために、`.well-known`を通じたSPからのオプトインも要求します。ブラウザはそのリスト内のRPオリジンの数を制限すべきです。また、RPが複数のSPを使用してIDを集約することも防止する必要があります。そのために、RPも`.well-known`でSPを宣言することを要求します。これらを合わせることで、大規模なサイトグループがWeb閲覧中に単一の高価値ユーザーをアンマスクするために協力できないことを保証します。

`example.com`の所有者が`example.co.uk`も運営しているとします。ログインは常に`example.com`で行われ、リンクデコレーションを通じて`example.co.uk`に伝播されます。両サイトをDBSCセッションで保護するために、`example.com`は既存の`Secure-Session-Registration`ヘッダーを引き続き使用すべきです：

```
Secure-Session-Registration: (ES256);path="/register";challenge="challenge"
```

DBSCセッションを`example.co.uk`に拡張する場合、サイトは`Secure-Session-Registration`ヘッダーに新しいパラメータを追加すべきです：

```
Secure-Session-Registration: (ES256);path="/register";challenge="challenge";provider_key="abc";provider_id="example.com id";provider_url="https://example.com"
```

`example.com`と`example.co.uk`が適切な`.well-known`エントリを持っていると仮定すると、これにより`example.co.uk`は`example.com`上のセッションと同じ鍵を使用して新しいDBSCセッションを登録します。これにより、ログイン時にユーザーが`example.com`で再認証することなく、DBSCが`example.co.uk`を保護できます。

---

## 4. 検討された代替案

### 4.1. WebAuthnとサイレントメディエーション

WebAuthnはサイトに特定の鍵管理機能を提供するため、DBSCと同じ目標を達成するために拡張できる可能性があります。しかし、WebAuthnのインタラクティブなユーザーサインインへの焦点が、DBSCのような機能の目標に反するAPIのいくつかの特性につながるため、このアプローチは取りません。例えば、WebAuthnクレデンシャルは特定のセッションに紐付けられていません。長寿命であることが意図されており、サイトデータとともにクリアされません。これはセッション鍵に必要なプライバシー特性とうまく合致しません。同様に、WebAuthnクレデンシャルは明示的なユーザーの意図で使用されるように設計されています。DBSCが提供する機能をWebAuthnに組み込むには、WebAuthnがサイレントに使用できる別の種類の鍵を確立する必要があります。これにより、WebAuthnとDBSCの両方に余分な複雑さが導入されます。代わりに、WebAuthnは安全なサインインを提供することを目的としており、DBSCはサインイン後のユーザーを保護する補完的なものであるという立場を取ります。

---

## 5. サーバー側の考慮事項

DBSCを使用するために、サイトオーナーは2つの新しいエンドポイントを確立する必要があります：登録エンドポイントとリフレッシュエンドポイントです。

**登録エンドポイント**は、ブラウザが`Secure-Session-Registration`ヘッダーを受信した後に非同期で接触されます。このエンドポイントは以下を行うべきです：

- 新しいセッション識別子を含むセッション設定を提供する。
- リクエストの公開鍵をセッション識別子に永続化し関連付ける。

**リフレッシュエンドポイント**はより機密性が高いです。このエンドポイントは、期限切れのバインドCookieを含むリクエストが行われるたびに接触され、そのレスポンスは元のリクエストをブロックします。レスポンスの失敗やバインドCookieの復元の失敗は、ブラウザエージェントがサービス拒否防止メカニズムを開始させるか、セッションを終了させることさえあります。いずれも将来のリクエストがバインドCookieなしになる可能性があります。このエンドポイントの期待される動作は以下のとおりです：

- 識別子によりセッションの公開鍵と最近のチャレンジを検索する。
- `Secure-Session-Response`ヘッダーが正しい鍵で最近のチャレンジに署名していることを検証する。ネットワーク遅延やレースコンディションにより、新しいチャレンジの発行後に古いチャレンジの署名を受信する可能性があることに注意。
- 新しいバインドCookieを発行する。
- オプションで現在のセッション設定を更新する。

ブラウザは、DBSCの採用によるレイテンシコストを最小限にするために、プロアクティブにセッションをリフレッシュすることを選択できます（MAY）。サイトは、バインドCookieが期限切れになった場合にのみリフレッシュが発生すると仮定すべきではありません。

リフレッシュエンドポイントは、クロスサイトフェッチが許可されている場合、タイミングサイドチャネルを通じてログイン状態を直接漏洩する可能性が高いです。サーバーは、受信リクエストがクロスサイトリクエストではなくユーザーエージェントによって開始されたものであることを確認するために、有効な`Sec-Secure-Session-Id`ヘッダーを確認できます。また、このエンドポイントに狭いCORSポリシーを設定し、クロスサイトオリジンがクレデンシャル付きでリクエストを行うことを許可しないことも推奨されます。DBSCのCORS統合は、延期されたリクエストがクレデンシャルを含む場合に暗黙的にクレデンシャルを含めることで、これを可能にするように設計されています。同様の理由から、リフレッシュエンドポイントが`X-Frame-Options`または`Cross-Origin-Resource-Policy`ヘッダーを介して埋め込みを拒否することも推奨されます。

`example.com`に2つのエンドポイントがあるとします：

- `/authenticated`は任意のリクエストオリジンに対して`Access-Control-Allow-Credentials`を返す。
- `/refresh`はDBSCリフレッシュエンドポイントである。

サイトは、DBSCが`/authenticated`へのクロスサイトリクエストを保護し、この1つのエンドポイントのタイミングサイドチャネルからのリスクは最小限であると考えています。ユーザーエージェントによってトリガーされるリフレッシュリクエストに対してクレデンシャルを暗黙的に許可しなかった場合、`/refresh`は任意のリクエストオリジンに対して`Access-Control-Allow-Credentials`を返すことが要求されます。すると、攻撃者は`/refresh`を直接フェッチすることでログイン状態を漏洩できます。

DBSCの`/refresh`への呼び出しが暗黙的にクレデンシャルを許可するため、`/refresh`エンドポイントは`Access-Control-Allow-Credentials`を返すことを拒否できます。それでもDBSCリフレッシュのコンテキストではクレデンシャル付きリクエストを受信します。他のサイトはクレデンシャル付きでエンドポイントを直接フェッチできなくなり、ログイン状態の容易なクロスサイト漏洩を防止します。

フェデレーテッドログインとDBSCを使用するサイト（[§3.3 フェデレーテッドセッション](#33-フェデレーテッドセッション)参照）は、フェデレーテッド鍵を持つセッションのみが受け入れられることを確保すべきです。フェデレーテッドセッションのセキュリティは、セッションプロバイダー（SP）ログイン時にマシンが侵害されていないことに依存します。マルウェアはマシンへの一時的なアクセスを使用して新しい鍵でリライイングパーティ（RP）上にセッションを登録できるためです。したがって、RPはSPから受信した適切な公開鍵で登録されたセッションのみを受け入れるべきです。

---

## 6. ユーザーエージェント側の考慮事項

DBSCは、ブラウザがCookieリフレッシュをスケジュールする際に多くの柔軟性を提供します。これにより、DBSCのレイテンシを軽減し、TPMとサーバーへの負荷を低減できます。ユーザーエージェントは以下の方法でCookieリフレッシュをスケジュールすることを推奨します：

- セッションが既に保留中のDBSCリフレッシュを持っている場合、別のリフレッシュを開始しない。これによりTPMの負荷が軽減され、よりシンプルなサーバー実装が可能になる。
- セッションクレデンシャルがまもなく期限切れになり、スコープ内のドキュメントがアクティブな場合、ユーザーエージェントは今後のリクエストのレイテンシを排除するためにプロアクティブにリフレッシュできる。

---

## 7. フレームワーク

この文書は、[RFC5234]で定義され[RFC7405]で更新されたABNF文法を使用して構文を指定し、[RFC9112]のセクション7で定義された`#rule`拡張、および同文書のセクション3.2.6で定義された`quoted-string`ルールを使用します。

この文書は、アルゴリズムと散文で使用される多くの基礎的な概念について、Infra Standard [INFRA]に依存しています。

### 7.1. セッションストア

ユーザーエージェントは**セッションストア**を維持します。これは登録可能ドメインからIDによるセッションマップへの順序付きマップです。セッションはユーザーエージェントの再起動後も永続すべきです。

### 7.2. IDによるセッション

**IDによるセッションマップ**は、所定の登録可能ドメインのセッション識別子からデバイスバウンドセッションへの順序付きマップです。

### 7.3. デバイスバウンドセッション

**デバイスバウンドセッション**は、以下のアイテムを持つ構造体です：

| アイテム | 説明 |
|---|---|
| セッション識別子 | 登録可能ドメイン上のセッションの一意識別子である文字列 |
| リフレッシュURL | セッションのリフレッシュに使用されるURLを表す文字列 |
| キャッシュされたチャレンジ | このセッションの次のチャレンジとして使用される文字列またはnull |
| セッションスコープ | このセッションのスコープ内のURLを定義するセッションスコープ |
| セッションクレデンシャル | セッションで使用されるセッションクレデンシャルのリスト |
| 有効期限タイムスタンプ | このセッションが削除されるべき時点 |
| セッション鍵ペア | セッションで使用される鍵ペア。秘密鍵は安全な方法で保管されるべきです |
| 許可されたリフレッシュイニシエーター | DBSCリフレッシュを開始することが許可されるホストを記述する文字列のリスト |

### 7.4. セッションスコープ

**セッションスコープ**は、以下のアイテムを持つ構造体です：

| アイテム | 説明 |
|---|---|
| オリジン | このセッションが登録されたオリジン |
| サイトを含む | セッションが単一のオリジンではなくサイト全体に適用されるかどうかを示すブーリアン |
| スコープ仕様 | セッションで使用されるスコープ仕様のリスト |

### 7.5. スコープ仕様

**スコープ仕様**は、以下のアイテムを持つ構造体です：

| アイテム | 説明 |
|---|---|
| タイプ | "include"または"exclude"のいずれかの文字列。この構造体で定義されたアイテムをスコープに追加するか削除するかを定義 |
| ホスト | このスコープ仕様が適用されるために一致する必要があるドメインまたはドメインパターンを定義する文字列 |
| パス | このスコープ仕様のパス部分を定義する文字列 |

### 7.6. セッションクレデンシャル

**セッションクレデンシャル**は、以下のアイテムを持つ構造体です：

| アイテム | 説明 |
|---|---|
| 名前 | クレデンシャルCookieの名前を定義する文字列 |
| Cookie属性 | クレデンシャルCookieの他の属性を定義する文字列。ユーザーエージェントはCookieと同じデフォルトを提供すべきです |

### 7.7. 登録可能オリジンラベル

ドメインの**登録可能オリジンラベル**は、ドメインの登録可能ドメインの最初のドメインラベルです。登録可能ドメインがnullの場合はnullです。例えば、`co.uk`と`de`の両方がパブリックサフィックスである場合、`example.co.uk`と`www.example.de`の両方の登録可能オリジンラベルは`example`です。

---

## 8. アルゴリズム

### 8.1. セッションの識別

このアルゴリズムは、ユーザーエージェント上に存在するすべてのセッションの中からセッションを識別する方法を記述します。セッション識別子は登録可能ドメイン内で一意です。

URL（url）とセッション識別子（session identifier）が与えられた場合、このアルゴリズムはデバイスバウンドセッションを返すか、そのようなセッションが存在しない場合はnullを返します。

1. domainをurlのホストの登録可能ドメインとする。
2. ユーザーエージェントのセッションストアがdomainを含まない場合、nullを返す。
3. domain sessionsをユーザーエージェントのセッションストア[domain]（IDによるセッションマップとして）とする。
4. domain sessions[session identifier]をデフォルトnullで返す。

### 8.2. URLがセッションのスコープ内にあるかの識別

このアルゴリズムは、URLがデバイスバウンドセッションのスコープ内にあるかどうかを判断する方法を記述します。URL（URL）とデバイスバウンドセッション（session）が与えられた場合、URLがスコープ内であれば"include"を返し、そうでなければ"exclude"を返します。

1. scopeをsessionのセッションスコープとする。
2. scopeの「サイトを含む」がtrueの場合、URLのオリジンがscopeのオリジンと同一サイトでなければ"exclude"を返す。
3. scopeの「サイトを含む」がfalseの場合、URLのオリジンがscopeのオリジンと同一オリジンでなければ"exclude"を返す。
4. URLがsessionのリフレッシュURLと一致する場合、"exclude"を返す。
5. scopeのスコープ仕様の各scope specificationについて：
   1. host patternをscope specificationのホスト、path patternをscope specificationのパスとする。
   2. URLのホストとhost patternで§8.4を実行し、falseが返された場合は次へ。
   3. 以下のいずれかが成立する場合、scope specificationのタイプを返す：
      - URLのパスがpath patternと完全に一致する。
      - path patternが'/'で終わり、URLのパスがpath patternで始まる。
      - URLのパスがpath patternの後に'/'が続くもので始まる。
6. "include"を返す。

### 8.3. リクエストがリフレッシュを許可されているかの識別

このアルゴリズムは、リクエストがデバイスバウンドセッションのリフレッシュをトリガーすることが許可されているかどうかを判断する方法を記述します。リクエスト（request）とデバイスバウンドセッション（session）が与えられた場合、リクエストがリフレッシュをトリガーできる場合は"allowed"を返し、そうでなければ"disallowed"を返します。

1. sessionのセッションスコープの「サイトを含む」がtrueで、requestのオリジンがsessionのセッションスコープのオリジンと同一サイトの場合、"allowed"を返す。
2. sessionのセッションスコープの「サイトを含む」がfalseで、requestのオリジンがsessionのセッションスコープのオリジンと同一オリジンの場合、"allowed"を返す。
3. sessionの許可されたリフレッシュイニシエーターの各initiator patternについて：
   1. requestのオリジンのホストとinitiator patternで§8.4を実行し、trueが返された場合、"allowed"を返す。
4. "disallowed"を返す。

### 8.4. ホストがパターンに一致するかの識別

このアルゴリズムは、ホストがパターンに一致するかどうかを判断する方法を記述します。ホスト（host）と文字列（pattern）を入力として受け取ります。patternがhostをカバーする場合、trueを返します。

1. patternが'\*'と等しい場合、trueを返す。
2. host stringをシリアライズされたhostとする。
3. patternが'\*'で始まり、hostがドメインの場合：
   1. patternが'\*.'で始まらない場合、falseを返す。
   2. host stringがpatternの最初の文字以外のすべてで終わる場合、trueを返す。
4. host stringがpatternと等しい場合、trueを返す。

パターン一致の例：

- `example.com`は`*`に一致する
- `example.com`は`example.com`に一致する
- `example.com`は`*.example.com`に一致**しない**
- `subdomain.example.com`は`*.example.com`に一致する

### 8.5. リフレッシュが必要なセッションの識別

リクエスト（request）が与えられた場合、このアルゴリズムはリフレッシュが必要なセッションを識別する方法を記述します。そのようなセッションが存在する場合、requestの進行をブロックすべきです。

1. domainをrequestのURLのホストの登録可能ドメインとする。
2. ユーザーエージェントのセッションストアがdomainを含まない場合、nullを返す。
3. domain sessionsをユーザーエージェントのセッションストア[domain]（IDによるセッションマップとして）とする。
4. domain sessionsの各sessionについて：
   1. sessionの有効期限タイムスタンプが現在時刻より前の場合、domain sessionsからsessionを削除して次へ。
   2. idをsessionのセッション識別子とする。
   3. タプル(domain, id)がrequestの延期されたデバイスバウンドセッションIDに含まれる場合、次へ。
   4. requestのURLとsessionで§8.2を実行。結果が"include"でない場合、次へ。
   5. requestとsessionで§8.3を実行。結果が"allowed"でない場合、次へ。
   6. requestとsessionのセッションクレデンシャルで§8.6を実行。結果がfalseの場合、次へ。
   7. (domain, id)をrequestの延期されたデバイスバウンドセッションIDに追加する。
   8. sessionの有効期限タイムスタンプを将来のタイムスタンプに設定する。正確な有効期限タイムスタンプの選択はユーザーエージェントに委ねられる。最大Cookie有効期間と合わせることが推奨される。
   9. sessionを返す。
5. nullを返す。

### 8.6. セッションクレデンシャルの欠落判定

このアルゴリズムは、リクエストにセッションクレデンシャルが欠落しているかどうかを識別する方法を記述します。リクエスト（request）とセッションクレデンシャルのリスト（credentials）が与えられた場合、credentialsのいずれかのクレデンシャルがrequestに欠落しているかどうかを示すブーリアンを返します。

1. credentialsの各credentialについて：
   1. credentialの属性を持つCookieがrequestに添付されない場合（[COOKIES]のセクション5.4参照）、次へ。
   2. requestのヘッダーリストに以下のすべての条件を満たすCookieが含まれている場合、次へ：
      - Cookieの名前がcredentialの名前と一致する。
      - Cookieの以下の属性がcredentialの属性と一致する：Domain、Path、Secure、HttpOnly、SameSite。
   3. trueを返す。
2. falseを返す。

### 8.7. チャレンジのキャッシュ

このアルゴリズムは、HTTPヘッダーで受信したチャレンジを処理する方法を記述します。

レスポンス（response）が与えられた場合、このアルゴリズムはデバイスバウンドセッションのキャッシュされたチャレンジを更新します。

1. header nameを"`Secure-Session-Challenge`"とする。
2. challenge listを、responseのヘッダーリストからheader nameと"list"を使用して構造化フィールド値を取得した結果とする。
3. challenge listがnullの場合、返す。
4. challenge listの各(challenge, params)について：
   1. challengeの型がsf-stringでない場合、次へ。
   2. session idをnullとする。
   3. params["id"]が存在しsf-stringの場合、session idをparams["id"]に設定する。
   4. session idがnullの場合、次へ。
   5. sessionをresponseのURLとsession idで§8.1を実行した結果とする。
   6. sessionがnullの場合、次へ。
   7. sessionのセッションクレデンシャルの各credentialについて：
      1. credentialの属性を持つCookieがresponseによって設定できない場合（[COOKIES]のセクション5.3参照）、次へ。
      2. challengeをsessionのキャッシュされたチャレンジとして保存する。
      3. 中断する。

### 8.8. リクエストの送信

このアルゴリズムは、デバイスバウンドセッションの登録またはリフレッシュのためにリクエストを送信する方法を記述します。リクエスト（originating request）、鍵ペア、URL（destination）、およびオプションの文字列session id、challenge、authorizationを入力として受け取ります。

ユーザーエージェントは、バインドクレデンシャルが欠落している場合にこれらのステップを実行しますが、いつでも実行してよい（MAY）です。バインドクレデンシャルが期限切れになる前にプロアクティブにリクエストを送信することで、DBSCのレイテンシコストを最小限にできます。

1. ユーザーエージェントは、ユーザーまたはサイトへのサービス拒否を防止するためにこのリクエストをスキップしてよい（MAY）。例えば、このセッションが過剰なTPM操作を要求している場合（ユーザーに害を与える）や、リフレッシュエンドポイントが最近到達不能であった場合（サイトへのサービス拒否リスク）。ユーザーエージェントがこれを行うことを選択した場合、§8.12のステップを実行して、サイトにこれを示すべきです。
2. 「セッションを終了する」アルゴリズムを定義する。
3. originating requestのURLのオリジンがdestinationのオリジンと同一サイトでない場合、返す。
4. signed challengeをnullとする。challengeまたはauthorizationがnon-nullの場合、DBSCプルーフを作成し、鍵ペアで署名し、結果をsigned challengeに格納する。
5. HTTP fetchで使用するリクエストを作成する。
6. リクエストのメソッドを"POST"に設定する。
7. リクエストのURLをdestinationに設定する。
8. リクエストのリダイレクトモードを"follow"に設定する。
9. signed challengeがnon-nullの場合、ヘッダー("Secure-Session-Response", signed challenge)をリクエストのヘッダーリストに追加する。
10. session idがnon-nullの場合、ヘッダー("Sec-Secure-Session-Id", session id)をリクエストのヘッダーリストに追加する。
11. authorizationがnon-nullの場合、ヘッダー("Authorization", authorization)をリクエストのヘッダーリストに追加する。
12. リクエストのイニシエーターをoriginating requestのイニシエーターに設定する。
13. リクエストのオリジンをoriginating requestのオリジンに設定する。
14. responseをリクエストに対してHTTP fetchを実行した結果とする。
15. responseがネットワークエラー、またはresponseのステータスが407または429の場合、返す。
16. responseのステータスが300以上400未満の場合、返す。
17. responseのステータスが403の場合：
    1. session idがnullの場合、返す。
    2. destinationとsession idで§8.1を実行し、結果をsessionとする。
    3. sessionがnullの場合、返す。
    4. そうでなければ、元の入力でこのアルゴリズムを再開し、challengeをsessionのキャッシュされたチャレンジに置き換える。
18. responseのステータスが400以上500未満の場合、セッションを終了して返す。
19. responseのステータスが500以上の場合、返す。ユーザーエージェントは、リフレッシュエンドポイントの一時的な障害による被害を制限するために、このセッションでの後続のリフレッシュリクエストにバックオフメカニズムをトリガーすることを選択できます。
20. session idがnon-nullで、responseのボディが空の場合、返す。
21. response、destination、session id、および鍵ペアで§8.9を呼び出す。

### 8.9. セッションの作成

登録リクエストに対するレスポンス（response）、destination（URL）、session id（文字列またはnull）、鍵ペアによりセッションを作成するために、以下のステップを実行します：

1. 「セッションを終了する」アルゴリズムを定義する。
2. responseのボディをJSONセッション指示として解析する。解析に失敗した場合、セッションを終了して返す。
3. JSONセッションのcontinueがfalseの場合、セッションを終了して返す。
4. session identifierをJSONセッションのsession_identifierとする。
5. JSON scopeをJSONセッションのscopeとする。
6. originを、JSON scopeのoriginが存在する場合はそれから構築したオリジン、存在しない場合はdestinationのオリジンとする。
7. JSONセッションのrefresh_urlに値がない場合、refresh URLをdestinationとする。
8. そうでなければ、refresh URLをdestinationとJSONセッションのrefresh_urlの値を解決した結果とする。
9. 以下の検証を実行する。いずれかが失敗した場合、セッションを終了して返す：
   - session idがnon-nullの場合、session identifierと一致しなければならない。
   - originは有効な非不透明オリジンでなければならない。
   - originはdestinationのオリジンと同一サイトでなければならない。
   - refresh URLはHTTPSスキームを持つかlocalhostでなければならない。
   - refresh URLのオリジンはdestinationのオリジンと同一サイトでなければならない。
   - すべてのJSONセッションクレデンシャルに"Partitioned"属性があってはならない。
10. destination domainをdestinationのホストの登録可能ドメインとする。
11. JSON scopeのinclude_siteがtrueの場合、追加の検証を実行する。
12. 新しいセッションを作成する。
13. セッションのプロパティを設定する（セッション識別子、リフレッシュURL、セッションスコープ、スコープ仕様、セッションクレデンシャル、鍵ペア、許可されたリフレッシュイニシエーター、有効期限タイムスタンプ）。
14. セッションクレデンシャルの各credentialについて、responseでCookieが設定可能な場合にセッションストアに保存する。

### 8.10. セッション登録の処理

レスポンス（response）とリクエスト（request）によるセッション登録を処理するには、以下のステップを実行します：

1. header nameを"`Secure-Session-Registration`"とする。
2. registration listを、responseのヘッダーリストからheader nameと"list"を使用して構造化フィールド値を取得した結果とする。
3. registration listがnullの場合、返す。
4. registration listの各(registration entry, params)について：
   1. registration entryがsf-inner-listでない場合、次へ。
   2. params["path"]が存在しないか、sf-string型でない場合、次へ。
   3. pathをparams["path"]とする。
   4. challengeとauthorizationをnullとする。
   5. params["challenge"]またはparams["authorization"]のいずれかが存在するがsf-string型でない場合、次へ。
   6. params["challenge"]が存在する場合、challengeに設定する。
   7. params["authorization"]が存在する場合、authorizationに設定する。
   8. endpointをresponseのURLに対するpathの相対解決結果とする。
   9. 鍵ペアをregistration entry、params、endpointで§8.11を実行した結果とする。
   10. 鍵ペアがnullの場合、返す。
   11. request、鍵ペア、endpoint、null（セッション識別子として）、challenge、authorizationで§8.8を呼び出す。

### 8.11. セッション鍵ペアの作成

このアルゴリズムは、リライイングパーティとセッションプロバイダー間の鍵共有を含むセッション鍵ペアの作成方法を記述します。`Secure-Session-Registration`ヘッダーのregistration entryとparams、および登録エンドポイントのURL（registration URL）を入力として受け取ります。セッションで使用する鍵ペアを返すか、鍵が不可能な場合はnullを返します。

1. algorithm listを空のリストとする。
2. registration entryの各algorithmについて：
   1. algorithmがsf-tokenでない場合、次へ。
   2. algorithmが`Secure-Session-Registration`でサポートされ、このクライアントでサポートされている暗号アルゴリズムを表す場合、algorithm listに追加する。
3. algorithm listが空の場合、nullを返す。
4. params["provider_key"]、params["provider_id"]、params["provider_url"]のいずれかが存在する場合：
   1. 3つの鍵のいずれかが欠落している場合、nullを返す。
   2. "device-bound-session-key-sharing"の使用許可をリクエストする。
   3. 許可が「拒否」の場合、nullを返す。
   4. プロバイダーURL、オリジン、ドメイン、識別子、セッションを検索する。
   5. プロバイダーセッションのJWKサムプリントがparams["provider_key"]と一致するか検証する。
   6. プロバイダーの`.well-known`エンドポイントを検証する。
   7. リライイングパーティの`.well-known`エンドポイントを検証する。
   8. プロバイダーセッションの鍵ペアを返す。
5. algorithm listのための新しい鍵ペアを返す。

### 8.12. デバッグヘッダーの追加

ユーザーエージェントがセッションを適用しないことを選択した場合にサイトが理解できるよう、ユーザーエージェントはリクエスト（request）にsf-token（token）と文字列（session id）でデバッグヘッダーを追加すべきです。

1. valueをトークン値tokenのsf-tokenとする。
2. valueにsf-parameter "session_identifier"をsession idに設定する。
3. skipped header valueを、リクエストのヘッダーリストから"Secure-Session-Skipped"と"list"型で構造化フィールド値を取得した結果とする。
4. skipped header valueがnullの場合、空のsf-listに設定する。
5. valueをskipped header valueに追加する。
6. ("Secure-Session-Skipped", skipped header value)をリクエストのヘッダーリストに設定する。

---

## 9. DBSCフォーマット

### 9.1. `Secure-Session-Registration` HTTPヘッダーフィールド

`Secure-Session-Registration`ヘッダーフィールドは、サーバーがクライアント上で新しいデバイスバウンドセッションを開始するためにレスポンスで使用できます。

`Secure-Session-Registration`はリスト構造化ヘッダー[RFC9651]です。そのABNFは：

```
SecureSessionRegistration = sf-list
```

リスト内の各アイテムはインナーリストでなければならず、インナーリスト内の各アイテムはサポートされているアルゴリズム（ES256、RS256）を表すsf-tokenでなければなりません（MUST）。現在、これら2つの値のみがサポートされています。

以下のsf-parameterが定義されています：

- **"path"**: 登録エンドポイントへのパスを伝えるsf-string。現在のURLからの相対パスまたは完全なURLが可能です。
- **"challenge"**: セッション登録で使用されるチャレンジを伝えるsf-string。
- **"authorization"**: 登録JWTにコピーされるsf-string。
- **"provider_key"**: 指定された公開鍵を持つセッションと鍵を共有すべきことを伝えるsf-string。
- **"provider_id"**: 指定されたセッション識別子を持つセッションと鍵を共有すべきことを伝えるsf-string。
- **"provider_url"**: 対応するサイト上のセッションと鍵を共有すべきことを伝えるsf-string。

`https://example.com/login.html`からの`Secure-Session-Registration`の例：

```
HTTP/1.1 200 OK
Secure-Session-Registration: (ES256);path="reg";challenge="cv";authorization="ac"
```

```
HTTP/1.1 200 OK
Secure-Session-Registration: (ES256 RS256);path="reg";challenge="cv"
```

```
HTTP/1.1 200 OK
Secure-Session-Registration: (ES256);path="reg1";challenge="cv1";authorization="a"
Secure-Session-Registration: (RS256);path="reg2";challenge="cv2";authorization="b"
```

### 9.2. `Secure-Session-Challenge` HTTPヘッダーフィールド

`Secure-Session-Challenge`ヘッダーフィールドは、サーバーがクライアントにチャレンジを送信するためにレスポンスで使用できます。将来の`Secure-Session-Response`ヘッダー内のDBSCプルーフで使用されることが期待されるか、ステータスが403の場合にCookieリフレッシュ中に即座に新しく署名されたDBSCプルーフを要求します。

```
SecureSessionChallenge = sf-string
```

#### 9.2.1. `Secure-Session-Challenge` 構造化ヘッダーシリアライゼーション

チャレンジは文字列で表されます。

チャレンジは`"id"`という名前のsf-parameterを持たなければなりません（MUST）。その値はセッション識別子を表す文字列でなければなりません（MUST）。

例：

```
HTTP/1.1 403 Forbidden
Secure-Session-Challenge: "new challenge";id="my session"
```

```
HTTP/1.1 200 OK
Secure-Session-Challenge: "new challenge";id="my session"
```

```
HTTP/1.1 200 OK
Secure-Session-Challenge: "c1";id="session 1", "c2";id="session 2"
```

### 9.3. `Secure-Session-Response` HTTPヘッダーフィールド

`Secure-Session-Response`ヘッダーフィールドは、クライアントがセッション鍵ペアの秘密鍵をまだ所有していることをサーバーに証明するために、ユーザーエージェントがリクエストでDBSCプルーフを送信するために使用できます。

```
SecureSessionResponse = sf-string
```

この文字列はDBSCプルーフJWTのみを含まなければなりません（MUST）。

### 9.4. `Sec-Secure-Session-Id` HTTPヘッダーフィールド

`Sec-Secure-Session-Id`ヘッダーフィールドは、現在のセッションのリフレッシュを要求するために、ユーザーエージェントがリクエストで使用できます。現在のセッション識別子が文字列引数として使用されます。

```
SecSecureSessionId = sf-string
```

### 9.5. `Secure-Session-Skipped` HTTPヘッダーフィールド

`Secure-Session-Skipped`ヘッダーフィールドは、ユーザーエージェントのポリシーにより意図的にバインドクレデンシャルが欠落していることを示すためにリクエストで使用できます。

```
SecureSessionSkipped = sf-list
```

リスト内の各アイテムは、Cookieリフレッシュをスキップする大まかな理由を表すsf-tokenでなければなりません（MUST）。サポートされている値は以下のみです："unreachable"、"server_error"、および"quota_exceeded"。これらのトークンは以下の状況で使用されるべきです：

- **"server_error"**: サーバーからのレスポンス（例：500ステータスコード）によりセッションリフレッシュが失敗したことを示す。
- **"unreachable"**: サーバーに到達できないためセッションリフレッシュが失敗したことを示す。
- **"quota_exceeded"**: ユーザーエージェントがリフレッシュしないことを選択したすべてのケース（例：最近のTPM操作が過剰）をカバーする。

### 9.6. JSONセッション指示フォーマット

サーバーは、セッション登録時およびオプションでセッションリフレッシュ時にJSONセッション指示を送信します。レスポンスにセッション指示が含まれる場合、JSON形式でなければなりません（MUST）。

JSONオブジェクトのルートに以下のキーが存在できます：

| キー | 説明 |
|---|---|
| session_identifier | セッション識別子を表す文字列。登録時は新しく作成されたセッションの識別子。continueの値がfalseの場合を除きMUST。 |
| refresh_url | 将来のリフレッシュリクエストに使用されるURLを表す文字列。OPTIONAL。 |
| continue | セッションが引き続き適用されるかどうかを示すブーリアン。falseに設定してセッションを終了可能。OPTIONAL（デフォルト：true）。 |
| scope | セッションでカバーされるリソースを記述するJSONセッションスコープ。continueの値がfalseの場合を除きMUST。 |
| credentials | このセッションで保護されるCookieを記述するJSONセッションクレデンシャルのリスト。continueの値がfalseの場合を除きMUST。 |
| allowed_refresh_initiators | DBSCリフレッシュを開始することが許可されるホストを記述する文字列のリスト。OPTIONAL（デフォルト：空リスト）。 |

例：

```json
{
  "session_identifier": "session_id",
  "refresh_url": "/RefreshEndpoint",
  "continue": false,
  "scope": {
    "origin": "https://example.com",
    "include_site": true,
    "scope_specification": [
      { "type": "include", "domain": "trusted.example.com", "path": "/only_trusted_path" },
      { "type": "exclude", "domain": "untrusted.example.com", "path": "/" },
      { "type": "exclude", "domain": "*.example.com", "path": "/static" }
    ]
  },
  "credentials": [{
    "type": "cookie",
    "name": "auth_cookie",
    "attributes": "Domain=example.com; Path=/; Secure; HttpOnly; SameSite=None"
  }],
  "allowed_refresh_initiators": [
    "example.com",
    "*.example.com",
    "site-embedding-example.com"
  ]
}
```

### 9.7. JSONセッションスコープ指示フォーマット

サーバーは、登録時およびオプションでセッションリフレッシュ時にJSONセッション指示内でJSONセッションスコープを送信します。

| キー | 説明 |
|---|---|
| origin | セッションが適用されるオリジンまたはサイトを示す文字列。OPTIONAL。 |
| include_site | セッションがオリジンスコープ（false）かサイトスコープ（true）かを示すブーリアン。MUST。 |
| scope_specification | デフォルトスコープ（全オリジンまたはサイト）への変更を記述するJSONセッションスコープルールのリスト。OPTIONAL。 |

### 9.8. JSONセッションスコープルールフォーマット

各JSONセッションスコープルールのルートに以下のキーが存在できます：

| キー | 説明 |
|---|---|
| type | ルールが宛先を含むか除外するかを示す文字列。MUST。値は"include"または"exclude"。 |
| domain | ルールに一致すべきドメインを示す文字列。ワイルドカードを含むことが可能。OPTIONAL（デフォルト：'\*'）。 |
| path | ルールに一致すべきパスプレフィックスを示す文字列。OPTIONAL（デフォルト：'/'）。 |

### 9.9. JSONセッションクレデンシャルフォーマット

| キー | 説明 |
|---|---|
| type | このセッションで保護されるクレデンシャルの種類を示す文字列。MUST。値は"cookie"。 |
| name | バインドCookieの名前を示す文字列。 |
| attributes | 保護されたCookieの期待される属性を含む文字列。 |

### 9.10. DBSCプルーフJWT構文

**DBSCプルーフ**は、クライアントが選択した秘密鍵でJSON Web Signature (JWS)を使用して署名されたJWTです。

DBSCプルーフのヘッダーには少なくとも以下のパラメータが含まれなければなりません（MUST）：

| パラメータ | 説明 |
|---|---|
| typ | "dbsc+jwt"でなければならない文字列 |
| alg | このJWTの署名に使用されるアルゴリズムを定義する文字列。"RS256"または"ES256"でなければならない |

DBSCプルーフのペイロードには少なくとも以下のクレームが含まれなければなりません（MUST）：

| クレーム | 説明 |
|---|---|
| aud | このJWTが最初に送信されたURL。例："https://example.com/refresh.html" |
| jti | 登録ヘッダーで送信されたチャレンジ値のコピー |
| iat | JWTが発行された時刻を識別するdouble。[RFC7519]で記述されるNumericDate値 |
| key | [RFC7517]で指定されるJWKを定義する辞書 |

`Secure-Session-Registration`ヘッダーフィールドに存在する場合、以下のクレームもMUST：

| クレーム | 説明 |
|---|---|
| authorization | `Secure-Session-Registration`ヘッダーフィールドからの文字列の直接コピー |

DBSCプルーフがリフレッシュリクエスト用の場合、以下のクレームがMUST：

| クレーム | 説明 |
|---|---|
| sub | セッション識別子を指定する文字列 |

`https://example.com/reg`に送信されるDBSCプルーフの例：

```json
// ヘッダー
{
  "alg": "ES256",
  "typ": "dbsc+jwt"
}
// ペイロード
{
  "aud": "https://example.com/reg",
  "jti": "cv",
  "iat": 1725579055.0,
  "key": {
    "kty": "EC",
    "crv": "P-256",
    "x": "6_GB2voQ0qroMh6OlDFCFS_SJriQi1PTvvBOhGZ3bHI",
    "y": "IegOJULyE7SxH_Cd1KCER7lWBvGFHQ-h0xyjzUjEIWE"
  },
  "authorization": "ac"
}
```

---

## 10. 他の仕様への変更

### 10.1. Fetch仕様への変更

この仕様は、HTTP-network-or-cache fetchアルゴリズムへの更新を要求します。リクエストには**延期されたデバイスバウンドセッションID**があり、以下で構成されるタプルのリストです：

- ドメイン（登録可能ドメイン）
- セッション識別子（文字列）

このリストは最初は空です。

ステップ8.21でCookieを計算した後、§8.5を実行します。結果のセッションがnon-nullの場合：

1. httpRequest、返されたセッションの鍵ペア、リフレッシュURL、セッション識別子、キャッシュされたチャレンジ、および空のauthorizationで§8.8を実行する。
2. 元の入力でHTTP-network-or-cache fetchを再開する。

この仕様は、新しいヘッダーを処理するために2つの新しい呼び出しも要求します。現在のHTTP network fetchのステップ14の後に以下のステップを実行します：

15. §8.10（セッション登録の処理）と§8.7（チャレンジのキャッシュ）を実行する。

### 10.2. Clear Site Data仕様への変更

この仕様は、Clear Site Data仕様のセクション4.2.5「オリジンのDOMアクセス可能ストレージのクリア」がオリジンに一致するスコープのすべてのデバイスバウンドセッションをクリアすることを要求します。また、セクション4.2.4を更新して、登録ドメインに一致するサイトのデバイスバウンドセッションをクリアすることも要求します。

---

## 11. IANAに関する考慮事項

永続メッセージヘッダーフィールドレジストリは以下の登録で更新されるべきです [RFC3864]：

### 11.1. Secure-Session-Challenge

- ヘッダーフィールド名: Secure-Session-Challenge
- 適用プロトコル: http
- ステータス: draft
- 著者/変更管理者: W3C
- 仕様書: この仕様（§9.2参照）

### 11.2. Sec-Secure-Session-Id

- ヘッダーフィールド名: Sec-Secure-Session-Id
- 適用プロトコル: http
- ステータス: draft
- 著者/変更管理者: W3C
- 仕様書: この仕様（§9.4参照）

### 11.3. Secure-Session-Registration

- ヘッダーフィールド名: Secure-Session-Registration
- 適用プロトコル: http
- ステータス: draft
- 著者/変更管理者: W3C
- 仕様書: この仕様（§9.1参照）

### 11.4. Secure-Session-Response

- ヘッダーフィールド名: Secure-Session-Response
- 適用プロトコル: http
- ステータス: draft
- 著者/変更管理者: W3C
- 仕様書: この仕様（§9.3参照）

### 11.5. Secure-Session-Skipped

- ヘッダーフィールド名: Secure-Session-Skipped
- 適用プロトコル: http
- ステータス: draft
- 著者/変更管理者: W3C
- 仕様書: この仕様（§9.5参照）

### 11.6. device-bound-sessions Well Known

Well-Known URIレジストリに `/.well-known/device-bound-sessions` を含めるように更新されるべきです。

このエンドポイントはJSONエンコードされた辞書を提供しなければなりません。3つのキーが定義されています：

- **"registering_origins"**: 文字列のリスト。サイト全体のセッションを登録することが許可されるオリジンを含む。
- **"relying_origins"**: 文字列のリスト。このサイトのセッションと鍵を共有する際にリライイングパーティ（RP）として許可されるオリジンを含む。
- **"provider_origin"**: オプションの文字列。このオリジンがリライイングパーティとして使用される場合のセッションプロバイダーのオリジンを含む。

例として、`https://example.com/.well-known/device-bound-sessions`が以下を提供する場合：

```json
{
  "registering_origins": [
    "https://subdomain.example.com",
    "https://subdomain.example.com:8000"
  ],
  "relying_origins": [
    "https://example.co.uk",
    "https://example-partner.com"
  ]
}
```

登録リクエストは、以下のいずれかが真である場合にのみサイトスコープセッションを定義できます：

- 登録エンドポイントのホストが`example.com`である
- 登録エンドポイントのオリジンが`https://subdomain.example.com`である
- 登録エンドポイントのオリジンが`https://subdomain.example.com:8000`である

さらに、`https://example.co.uk`と`https://example-partner.com`は`https://example.com`上のセッションと鍵を共有することが許可され、フェデレーテッドログインとDBSC保護の両方を実現できます。これを行うには、両サイトが`.well-known`ファイルに以下のエントリを提供する必要があります：

```json
{
  "provider_origin": "https://example.com/"
}
```

---

## 12. 変更履歴

これはこの仕様の初期ドラフトです。

## 13. 謝辞

（なし）

---

## 適合性

### 文書の規約

適合性要件は、記述的な主張とRFC 2119用語の組み合わせで表現されます。この文書の規範的な部分のキーワード "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、"OPTIONAL" は、RFC 2119に記述されているとおりに解釈されるべきです。ただし、読みやすさのために、この仕様ではこれらの用語はすべて大文字で表示されているわけではありません。

この仕様のすべてのテキストは、非規範的と明示的にマークされたセクション、例、および注釈を除いて規範的です。[RFC2119]

### 適合アルゴリズム

アルゴリズムの一部として命令形で表現された要件（「先頭のスペース文字を削除する」や「falseを返しこれらのステップを中止する」など）は、アルゴリズムを導入する際に使用されたキーワード（"must"、"should"、"may"等）の意味で解釈されるべきです。

アルゴリズムまたは特定のステップとして表現された適合性要件は、最終結果が同等であれば、任意の方法で実装できます。特に、この仕様で定義されたアルゴリズムは理解しやすいことを意図しており、パフォーマンスを意図したものではありません。実装者は最適化することが推奨されます。

---

*原文: https://www.w3.org/TR/dbsc/*
*翻訳日: 2026年2月14日*
